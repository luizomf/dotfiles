#!/usr/bin/env bash
# vim: set filetype=sh :

# Reset
RESET='\033[0m'

# Cores normais
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'

# FunÃ§Ãµes para printar mensagens coloridas de forma legÃ­vel
log() {
  printf "${CYAN}%s${RESET}\n" "$1"
}

loginfo() {
  log "ðŸ”µ $1"
}

logsuccess() {
  printf "ðŸŸ¢ ${GREEN}%s${RESET}\n" "$1"
}

logwarning() {
  printf "ðŸŸ¡ ${YELLOW}%s${RESET}\n" "$1"
}

logerror() {
  printf "ðŸ”´ ${RED}%s${RESET}\n" "$1"
}


dtouch() {
  mkdir -p "$(dirname "$1")"
  touch "$1"
}

componentTs() {
  # code -r src/components/"$1"/index.tsx src/components/"$1"/"$1".tsx src/components/"$1"/"$1".module.css
  mkdir -p src/components/"$1"
  zed -a src/components/"$1"/index.tsx
  zed -a src/components/"$1"/"$1".spec.tsx
  zed -a src/components/"$1"/"$1".test.tsx
  zed -a src/components/"$1"/"$1".stories.tsx
  zed -a src/components/"$1"/"$1".module.css
}

componentJs() {
  code -r src/components/"$1"/styles.js src/components/"$1"/index.jsx src/components/"$1"/stories.jsx src/components/"$1"/"$1".spec.jsx
}

aula_c() {
  [ -z "$1" ] && echo "Empty Param, send a class name" && return
  ffmpeg -i \
    "${HOME}/Desktop/$1.mp4" -vf "scale=1920:1080" -sws_flags lanczos \
    -c:v libx264 -crf 23 -preset slow -c:a aac -b:a 160k \
    "${HOME}/Desktop/$1-c.mp4"
}

memoryUsage() {
  # shellcheck disable=SC2009
  ps -A -o rss,comm | grep -E "$1" | grep -v grep | awk '{ sum += $1 } END { printf "%.2f MB\n", sum / 1024 }'
}

deletePythonCache() {
    echo "Limpando diretÃ³rios de cache e build..."

    deactivate

    find . -type d \( -name "__pycache__" -o -name ".pytest_cache" -o -name ".tox" -o -name "*.egg-info" -o -name "build" -o -name "dist" \) -exec rm -r {} \;
    find . -type f \( -name "*.pyc" -o -name "*.pyo" \) -delete

    echo "Limpeza concluÃ­da com sucesso!"
}



iterm() {
    cwd=$(pwd)
    open -a iterm "$cwd"
}

restart_terminal() {
  fc -W
  # shellcheck source=../.zshrc
  . "${HOME}/.zshrc"
  tmux respawn-window -k
}

show_colors() {
  for i in {0..255}; do
    print -P ">>>  $(printf '%03d' "$i")  %F{$i}Dummy text%f  %F{232}%K{$i} dummy text %k%f  <<<"
  done
}

gitconfig() {
  set -e

  log "Your name:"
  read -r NAME

  log "Your e-mail:"
  read -r EMAIL

  log

  # Initialize git
  log "Command: git init"
  git init

  # Configurar o nome do usuÃ¡rio"
  log "Command: git config user.name \"${NAME}\""
  git config user.name "${NAME}"

  # Configurar o e-mail do usuÃ¡rio"
  log "Command: git config user.email \"${EMAIL}\""
  git config user.email "${EMAIL}"

  # Muda o nome do branch para main"
  log "Command: git branch -m main"
  git branch -m main

  # Garantir que o Git converta CRLF para LF apenas ao commitar (Ã³timo para projetos multiplataforma)"
  log "Command: git config core.autocrlf input"
  git config core.autocrlf input

  # ForÃ§ar o Git a usar LF como fim de linha sempre"
  log "Command: git config core.eol lf"
  git config core.eol lf

  # Verificar as configuraÃ§Ãµes aplicadas"
  log "Command: git config --list --local"
  # git config --list --local
  #
  # Adicionando o repositÃ³rio"
  # log "git add ."
  # log "git commit -m \"initial\""
  # log "git remote add origin LINK-REPO"
  # log "git push origin main -u  "
}

tmux_respawn_all() {
  loginfo "Starting  Clean & Respawn Tmux Panes"

  loginfo "Saving history: fc -W"
  fc -W

  loginfo "Sourcing .zshrc"
  # shellcheck source=../.zshrc
  . "${HOME}/.zshrc"

  loginfo "Cleaning nvim logs"
  cleanNeovimLogs

  loginfo "Synchronizing zsh history"
  "${HOME}/dotfiles/scripts/zsh_history_sync.py"

  logwarning "Removing old tmux sessions..."
  rm -Rfv "${HOME}/.local/share/tmux/resurrect"/*.*
  rm -Rfv "${HOME}/.local/share/tmux/resurrect/last"

  loginfo "Nap a bit..."
  sleep 1

  loginfo "Saving current session"
  "${HOME}/.tmux/plugins/tmux-resurrect/scripts/save.sh"

  loginfo "Nap a bit again..."
  sleep 1

  logsuccess "Tmux resurrect cleaned!"
  loginfo "Restoring sessions now"

  "${HOME}/.tmux/plugins/tmux-resurrect/scripts/restore.sh"

  loginfo "Nap again, last time..."
  sleep 1

  loginfo "Respawning all panes"
  for pane in $(tmux list-panes -a -F '#D'); do
    tmux respawn-pane -k -t "$pane";
  done

  sleep 1

  loginfo "Saving sessions after respawn..."
  "${HOME}/.tmux/plugins/tmux-resurrect/scripts/save.sh"

  logsuccess "All done. I hope it helps."
}

cleanNeovimLogs() {
  loginfo "Starting nvim cleanup"

  [[ -d ${HOME}/.local/state/nvim ]] && rm -Rfv ~/.local/state/nvim/*.log
  [[ -d ${HOME}/.cache/nvim ]] && {
      rm -Rfv ~/.cache/nvim/*.log
      "rm -Rfv ${HOME}/.cache/nvim/shada"
      "rm -Rfv ${HOME}/.cache/nvim/sessions"
  }

  logsuccess "NeoVim cleaned..."
}

# Wrapper para resolver um problema chato de SSH:
# Minha confusÃ£o se estou local ou no server
sshc() {
  if [ -z "$TMUX" ]; then
    # NÃ£o estamos no tmux
    original_term=$TERM
    TERM=$SSH_TERM
    command ssh "${@}"
    TERM=$original_term
    return
  fi

  tmux setenv -g SSH_ACTIVE 1

  # Pega o estilo atual do tmux
  original_sl=$(tmux show-options -gqv status-left)
  original_term=$TERM

  # LÃ³gica de limpeza
  # shellcheck disable=SC2329,SC2317
  _cleanup() {
    tmux setenv -g SSH_ACTIVE 0
    tmux set -g status-left "$original_sl"
    TERM="$original_term"
  }

  trap _cleanup EXIT

  TERM=$SSH_TERM
  command ssh -q "$@"
}

tmuxns() {
  session_name="$1"
  shift

  tmux new-session -d -s "$session_name" -c "$(pwd)"

  for arg in "$@"; do
    tmux new-window -t "$session_name" -n "${arg}" -c "$(pwd)"
  done
}

# zsh has no decent interactive help for builtins, so yes, this calls Bash.
# If this offends you, feel free to read 200 pages of `man zshbuiltins` instead.
help() {
  [[ -o interactive ]] || return

  if [[ $# -eq 0 ]]; then
    bash -c help
  else
    bash -c "help $*"
  fi
}

tmux_make_sessions() {
  projects_dir=${1:-${HOME}/Desktop/tutoriais_e_cursos}

  [[ -d "${projects_dir}" ]] || logerror "'${projects_dir}' is not a directory"

  tmux kill-server

  rm -Rf ~/.local/share/tmux/resurrect/*.*

  tmux start-server

  for pane in $(tmux list-panes -a -F "#D"); do
    logwarning "Removing pane ${pane}"
    tmux kill-pane -t "${pane}"
  done

  for window in $(tmux list-windows -a -F "#S:#W"); do
    logwarning "Removing window ${window}"
    tmux kill-window -t "${window}"
  done

  for session in $(tmux list-sessions -a -F "#S"); do
    logwarning "Removing session ${session}"
    tmux kill-session -t "${session}"
  done

  tmux new -s "HOME" -d -n code -c "${HOME}"
  tmux neww -t "HOME" -d -n term -c "${HOME}"

  tmux new -s "dotfiles" -d -n code -c "${HOME}/dotfiles"
  tmux neww -t "dotfiles" -d -n term -c "${HOME}/dotfiles"

  find "${projects_dir}" -mindepth 1 -maxdepth 1 -type d -print0 | while IFS= read -r -d '' dir; do
    dirname=$(basename "${dir}")

    session_name="${dirname}"
    first_window_name="code"
    second_window_name="term"

    tmux kill-session -t "${session_name}"
    tmux kill-window -t "${session_name}:${first_window_name}"
    tmux kill-window -t "${session_name}:${second_window_name}"

    tmux new -s "${session_name}" -d -n "${first_window_name}" -c "${dir}"
    tmux neww -t "${session_name}" -d -n "${second_window_name}" -c "${dir}"
  done

  ~/.tmux/plugins/tmux-resurrect/scripts/save.sh
  tmux
}

tmux_run_all_panes() {
  for window in $(tmux list-panes -a -F "#D"); do
    tmux send-keys -t "$window" "$@" C-m
  done
}

ollama_stop_all() {
  ollama ps | awk 'NR>1 {print $1}' | xargs -L 1 ollama stop
}

ollama_update_models() {
  for model in $(ollama ls | tail +2 | cut -d ' ' -f 1); do
    loginfo "Pulling: ${model}"
    ollama pull "${model}"
  done
}

updateall() {
  log "Sleeping for 1 sec..."
  sleep 1

  log "Writing history to file"
  fc -W
  log "Sourcing .zshrc"
  # shellcheck source=../.zshrc
  source "${HOME}/.zshrc"

  log "Sourcing .tmux.conf"
  # shellcheck source=../tmux/.tmux.conf
  tmux source "${HOME}/.tmux.conf"

  log "Cleaning nvim logs..."
  cleanNeovimLogs

  log "Synchronizing ZSH history to local computers..."
  pyenv exec "${HOME}/dotfiles/scripts/zsh_history_sync.py"
  sleep 5

  log "Running brew update"
  brew update
  log "Running brew upgrade"
  brew upgrade
  log "Running omz update"
  omz update
  log "Running brew cleanup"
  brew cleanup

  log "Regenerating brew bundle file"
  brew bundle dump --file="${HOME}/dotfiles/homebrew/Brewfile" --force --no-restart

  log "Running uv self update"
  uv self update
  log "Running uv upgrade tools: pyright mupy ruff"
  uv tool upgrade pyright mypy ruff
  log "Running uv python upgrade"
  uv python upgrade

  log "Running npm upgrade for global packages: gemini npm prettier pyright"
  npm -g upgrade @google/gemini-cli npm prettier pyright

  log "Sleeping for 1 sec..."
  sleep 1
}

clear () {
  tmux clear-history
  printf '\e[H\e[2J\e[3J'
}

convert_for_youtube() {
  INPUT=
  OUTPUT=
  SONG=

  help_msg() {
    printf "Usage: %s -i <input> -o <output> [-s <song>]\n\n" "${0##*/}"
    printf "Options:\n"
    printf "  -i, --input   FILEPATH  Source video you wish to use.\n"
    printf "  -o, --output  FILEPATH  Output video after conversion.\n"
    printf "  -s, --song    1 or 0    1=add song, 0=don't add song.\n"
    printf "  -h, --help              Display this help information.\n"
  }

  error_then_help() {
    help_msg
    printf "\nError: %s\n" "$1"
    return 1
  }

  require_value() {
    [[ -n "${2:-}" ]] || error_then_help "$1 requires a value"
  }

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--input)
        require_value "$1" "${2:-}" || return 1
        INPUT=$2
        shift 2
        ;;
      -o|--output)
        require_value "$1" "${2:-}" || return 1
        OUTPUT=$2
        shift 2
        ;;
      -s|--song)
        require_value "$1" "${2:-}" || return 1
        SONG=TRUE
        shift 2
        ;;
      -h|--help)
        help_msg
        return 0
        ;;
      --)
        shift
        break
        ;;
      *)
        error_then_help "Unknown argument: $1"
        return 1
        ;;
    esac
  done

  [[ -z "$INPUT" ]] && logerror "Missing input" && return 1
  [[ -z "$OUTPUT" ]] && logerror "Missing output" && return 1
  [[ "${INPUT}" == "$OUTPUT" ]] && logerror "Input file is identical to output file." && return 1

  if [[ -z $SONG ]]; then 
    ffmpeg_yt -i "${INPUT}" -o "${OUTPUT}"
  else
    SONG="/Users/luizotavio/Library/CloudStorage/GoogleDrive-todoespacoonline@gmail.com/Meu Drive/BKP_EXTERNO_2/Edicao/youtube_library_music/lofi/todas-30db.mp3"
    ffmpeg_yt_music \
      -i "${INPUT}" \
      -o "${OUTPUT}" \
      -s "${SONG}"
  fi
}

ffmpeg_yt() {
  echo ffmpeg -fflags +genpts -fflags +igndts \
    -i "${INPUT}" \
    -c:v libx264 -profile:v high -crf 13 -bf 2 -g 15 -coder 1 -pix_fmt yuv420p -preset slow \
    -c:a aac -ar 48000 -b:a 384k \
    -shortest \
    -movflags +faststart \
    "${OUTPUT}"

  ffmpeg -fflags +genpts -fflags +igndts \
    -i "${INPUT}" \
    -c:v libx264 -profile:v high -crf 13 -bf 2 -g 15 -coder 1 -pix_fmt yuv420p -preset slow \
    -c:a aac -ar 48000 -b:a 384k \
    -shortest \
    -movflags +faststart \
    "${OUTPUT}"
}

ffmpeg_yt_music() {
  echo ffmpeg -fflags +genpts -fflags +igndts \
    -i "${INPUT}" -i "${SONG}" \
    -filter_complex "[0:a][1:a]amix=inputs=2:duration=first:normalize=0[a]" \
    -map 0:v -map "[a]" \
    -c:v libx264 -profile:v high -crf 13 -bf 2 -g 15 -coder 1 -pix_fmt yuv420p -preset slow \
    -c:a aac -ar 48000 -b:a 384k \
    -shortest \
    -movflags +faststart \
    "${OUTPUT}"

  ffmpeg -fflags +genpts -fflags +igndts \
    -i "${INPUT}" -i "${SONG}" \
    -filter_complex "[0:a][1:a]amix=inputs=2:duration=first:normalize=0[a]" \
    -map 0:v -map "[a]" \
    -c:v libx264 -profile:v high -crf 13 -bf 2 -g 15 -coder 1 -pix_fmt yuv420p -preset slow \
    -c:a aac -ar 48000 -b:a 384k \
    -shortest \
    -movflags +faststart \
    "${OUTPUT}"
}

backup_ssh() {
  if [[ -z "${HOST:-}" ]]; then
    HOST="$(hostname)"
  fi

  (
    ssh_dir="${HOME}/.ssh"
    output_dir="${HOME}/Desktop"
    output_file="${output_dir}/$(date "+%Y-%m-%d-%H-%M-%S-${HOST}").7z"

    [[ -z "${HOST:-}" ]] && logerror "No hostname found" && return 1
    [[ ! -d "${ssh_dir}" ]] && logerror "No .ssh directory found" && return 1

    if ! command -v 7z >/dev/null; then
      logerror "No 7zip not found"
      return 1
    fi

    echo
    cd "${HOME}"

    if 7z a -t7z -m0=lzma2 -mx=9 -mhe=on "${output_file}" "${ssh_dir}" -p; then

      loginfo "File saved to: ${output_file}"
      echo
      loginfo "Let's make sure the file and password is valid:"
      loginfo 7z x "${output_file}"
      echo

      loginfo "Use this command to extract: "

      if ! 7z t "${output_file}"; then
        rm -Rf "${output_file}"
        logerror "Try again."
        return 1
      fi

      echo

    else
      logerror "Command failed."
      rm -Rf "${output_file}"
    fi

    echo
  )
}

killgui() {
  echo ">> Stopping graphical interface (sddm + wayland)..."
  sudo systemctl stop sddm
  sudo systemctl stop graphical.target
  echo ">> GUI stopped. SSH-only mode active."
}

startgui() {
  echo ">> Starting graphical interface..."
  sudo systemctl start graphical.target
  sudo systemctl start sddm
}

commit_dotfiles() {
  MSG="${1:-}"
  CURDIR="$(pwd)"

  if [[ -z $MSG ]]; then
    echo "Action Cancelled"
    return 0
  fi

  cd "${HOME}/dotfiles" || return 1

  git add .
  git commit -m "${MSG}"
  git push
  ssh m4128 'cd ~/dotfiles ; git pull'
  ssh fedoraair 'cd ~/dotfiles ; git pull'
  # shellcheck disable=SC1090
  #
  source ~/.zshrc
  tmux source ~/.tmux.conf ; fc -W

  cd "${CURDIR}" || return 1
}
